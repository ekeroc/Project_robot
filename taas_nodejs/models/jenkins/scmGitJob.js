/**
 * @fileoverview Jenkins integration for Git support
 */
var util = require('util');
var path = require('path');
var validator = require('validator');
var logger = require('./getLogger').logger;
var JenkinsJob = require('./job').JenkinsJob;

const JOBTYPE = 'scm/git';
const JOBPREFIX = 'ScmGit';
const JOBSLAVE = 'taas && base';

/**
 * Build a Jenkins SCM Git job instance.
 * @classdesc Jenkins SCM Git job
 * @constructor
 * @extends JenkinsJob
 * @param {String} jobName job name
 */
function JenkinsScmGitJob(jobName) {
    // call the parent constructor
    JenkinsJob.call(this, jobName);
    this._type = JOBTYPE;
}

// inherit from JenkinsJob
util.inherits(JenkinsScmGitJob, JenkinsJob);


/**
 * Create a new name for Jenkins SCM Git job. <br/>
 * @returns {string} new job name
 * @private
 */
function gitCreateJobName() {
    return JenkinsJob._createJobName(JOBPREFIX);
}


/**
 * Create the Jenkins job configuration options
 * @private
 * @static
 * @param {Object} opts job settings. See {@link JenkinsScmGitJob.getCreateOptionsDescriptor} for more info.
 * @param {string} jobName job name
 * @param {fn} callback receives the job creation response. Parameters:
 *   <ul>
 *     <li>err: error object</li>
 *     <li>jobCfgOpts: an object representing Jenkins job XML configuration options</li>
 *   </ul>
 */
JenkinsScmGitJob.__createJobCfg = function(opts, jobName, callback) {

    function onError(err) {
        logger.debug(err);
        return callback(err);
    }

    function getErrOptions(optValidation) {
        var errorOpts = optValidation.map(function(val) {return val.name;});
        return errorOpts.join(',');
    }

    var optValidation = JenkinsScmGitJob.__validateCreateOptions(opts);
    if (optValidation.length) {
        return onError(new Error('Validation error for options ' + getErrOptions(optValidation)));
    }

    var cfgOpts = {
        description: 'This job is generated by TaaS::JenkinsScmGitJob.',
        assignedNode: JOBSLAVE,
        scm: {
            git : {
                url: opts.repoURL,
                branch: opts.repoBranch
            }
        }
    };

    // support credentials
    if (opts.username && opts.privateKey) {
        cfgOpts._credentials = [{
            idSuffix: '',
            username: opts.username,
            privateKey: opts.privateKey
        }];
        cfgOpts.scm.git.credentialsId = jobName;
    }
    else if (opts.username) {
        cfgOpts._credentials = [{
            idSuffix: '',
            username: opts.username,
            password: opts.password
        }];
        cfgOpts.scm.git.credentialsId = jobName;
    }
    return callback(null, cfgOpts);
};


/**
 * Create a new Jenkins SCM Git Job.
 * @static
 * @param {Object} opts job settings. See {@link JenkinsScmGitJob.getCreateOptionsDescriptor} for more info.
 * @param {fn} callback receives the job creation response. Parameters:
 *   <ul>
 *     <li>err: error object</li>
 *     <li>code: creation response. Options:
 *       <ul>
 *         <li>JenkinsJob.UPDATE.OK</li>
 *         <li>JenkinsJob.UPDATE.ALREADY_EXISTS</li>
 *         <li>JenkinsJob.UPDATE.ERROR</li>
 *       </ul>
 *     </li>
 *     <li>jobName: the new job name</li>
 *   </ul>
 */
JenkinsScmGitJob.create = function(opts, callback) {
    var jobName = gitCreateJobName();
    JenkinsScmGitJob.__createJobCfg(opts, jobName, function(err, jobCfgOpts) {
        if (err) {
            let errObj = new Error('Jenkins SCM Git job creation error: ' + err.toString());
            logger.debug(errObj);
            return callback(errObj, JenkinsJob.UPDATE.ERROR);
        }
        return JenkinsJob._create(jobName, JOBTYPE, jobCfgOpts, callback);
    });
};


const GIT_OPTIONS_DESCRIPTOR = [
    {
        name: 'repoURL',
        displayName: 'Repository URL',
        displayHint: 'Git repository URL',
        type: JenkinsJob.DESCRIPTOR_TYPE.URL,
        alreadyExists: true,
        required: true
    },
    {
        name: 'repoBranch',
        displayName: 'Repository branch',
        displayHint: 'Git repository branch',
        type: JenkinsJob.DESCRIPTOR_TYPE.STRING,
        defaultValue: '*/master'
    },
    {
        name: 'username',
        displayName: 'Username',
        displayHint: 'Git repository username. This is only needed if authentication is required.',
        type: JenkinsJob.DESCRIPTOR_TYPE.STRING,
    },
    {
        name: 'password',
        displayName: 'Password',
        displayHint: 'Git repository password. This is only needed if password-based authentication is required.',
        type: JenkinsJob.DESCRIPTOR_TYPE.PASSWORD,
    },
    {
        name: 'privateKey',
        displayName: 'Private key',
        displayHint: 'Git repository private key. This is only needed if key-based authentication is required.',
        type: JenkinsJob.DESCRIPTOR_TYPE.STRING,
        longText: true
    },
];


/**
 * Get the option descriptor for the static create method
 *
 * @static
 * @returns {array} option descriptor
 */
JenkinsScmGitJob.getCreateOptionsDescriptor = function() {
    return GIT_OPTIONS_DESCRIPTOR;
};


/**
 * Get the option descriptor for the update method
 *
 * @static
 * @returns {array} option descriptor
 */
JenkinsScmGitJob.getUpdateOptionsDescriptor = function() {
    return GIT_OPTIONS_DESCRIPTOR;
};


/**
 * @private
 */
JenkinsScmGitJob.__validateCreateOptions = function(opts) {
    var errors = [];

    var urlValidationOpts = {
        protocols: ['http', 'https', 'ssh'],
        require_protocol: true,
        require_valid_protocol: true
    };
    if (!opts.repoURL || !validator.isURL(opts.repoURL, urlValidationOpts)) {
        errors.push({
            name: 'repoURL',
            err: new Error('Invalid repository URL option')
        });
    }

    var branchValidator = /^\S+$/;  // exclude space characters
    if (opts.repoBranch && !branchValidator.test(opts.repoBranch)) {
        errors.push({
            name: 'repoBranch',
            err: new Error('Invalid repository branch')
        });
    }

    var usernameValidator = /^\S+$/;  // exclude space characters
    if (opts.username && !usernameValidator.test(opts.username)) {
        errors.push({
            name: 'username',
            err: new Error('Invalid username')
        });
    }

    return errors;
};


/**
 * Validate the options for the static create method<br/>
 *
 * @static
 * @returns {object} validation results. Attributes:
 *   <ul>
 *     <li>result (boolean): validation results</li>
 *     <li>message (string): the message when an error is detected</li>
 *   </ul>
 */
JenkinsScmGitJob.validateCreateOptions = function(opts) {
    return JenkinsScmGitJob.__validateCreateOptions(opts);
};


/**
 * Validate the options for the update method<br/>
 *
 * @static
 * @returns {object} validation results. Attributes:
 *   <ul>
 *     <li>result (boolean): validation results</li>
 *     <li>message (string): the message when an error is detected</li>
 *   </ul>
 */
JenkinsScmGitJob.validateUpdateOptions = function(opts) {
    return JenkinsScmGitJob.__validateCreateOptions(opts);
};


/**
 * Update Jenkins job configuration.
 * @param {Object} opts job settings. See {@link JenkinsScmGitJob.getCreateOptionsDescriptor} for more info.
 * @param {fn} callback receives the job update response. Parameters:
 *   <ul>
 *     <li>err: error object</li>
 *     <li>code: update response. Options:
 *       <ul>
 *         <li>JenkinsJob.UPDATE.OK</li>
 *         <li>JenkinsJob.UPDATE.NOT_EXISTS</li>
 *         <li>JenkinsJob.UPDATE.ERROR</li>
 *       </ul>
 *     </li>
 *   </ul>
 */
JenkinsScmGitJob.prototype.update = function(opts, callback) {
    var self = this;
    JenkinsScmGitJob.__createJobCfg(opts, self._name, function(err, jobCfgOpts) {
        if (err) {
            let errObj = new Error('Jenkins SCM Git job update error: ' + err.toString());
            logger.debug(errObj);
            return callback(errObj, JenkinsJob.UPDATE.ERROR);
        }
        return self._update(jobCfgOpts, callback);
    });
};


JenkinsScmGitJob.prototype.getRunFileList = function(opts, callback) {
    // no run files
    return callback(null, []);
};


JenkinsScmGitJob.prototype.getRunStatsList = function(opts, callback) {
    // no run statistics
    return callback(null, []);
};


JenkinsScmGitJob.prototype.getRunStats = function(opts, callback) {
    return callback(new Error('No run statistics available'));
};


module.exports.JenkinsScmGitJob = JenkinsScmGitJob;
module.exports.staticCreate = JenkinsScmGitJob.create;
module.exports.constructor = JenkinsScmGitJob;
